---
title: "Piecewise Linear Regression for Groundwater Trends"
author: "Luna Herschenfeld-Catalan"
---

# Data Access

## Groundwater Data

Access groundwater data [here](https://zenodo.org/records/10003697). 

Citation: Groundwater level data, aquifer system boundaries, and Supplementary Tables associated with Jasechko, S., Seybold, H., Perrone, D., Fan, Y., Shamsudduha, M., Taylor, R.G., Fallatah, O., Kirchner, J.W. Rapid groundwater decline and some cases of recovery in aquifers globally. Nature, https://doi.org/10.1038/s41586-023-06879-8 (2024).

- Depth to groundwater is saved as `AnnualDepthToGroundwater.csv`. Due to the way its measured, positive slope values signify declines in groundwater. 
- Groundwater elevation is saved as `AnnualGroundwaterElevation.csv`. 

## US data

Accessed us boundary data [here](https://www.census.gov/cgi-bin/geo/shapefiles/index.php?year=2023&layergroup=States+%28and+equivalent%29)

# Data Exploration 

```{r setup, include=FALSE, message=FALSE, warning = FALSE}
library(tidyverse)
library(here)

# to make geospatil objects
library(sf)

library(usmap)

library(forecast)

# fill in the missing NA values
library(performanceEstimation)

library(tidyfit)
library(lubridate)
```


Analysis should include 
```{r message=FALSE, warning = FALSE}
# read in the depth data
depth <- read_csv(here('data', "AnnualDepthToGroundwater.csv"))

# read in the elevation data
elevation <- read_csv(here('data', "AnnualGroundwaterElevation.csv"))

# reda in map data
us <- st_read(here("data", "tl_2023_us_state", "tl_2023_us_state.shp")) %>% 
  janitor::clean_names() %>% 
  select(name, geometry)
```


```{r message=FALSE, warning = FALSE}

location <- depth %>% 
  select(StnID, Lat, Lon) %>% 
  distinct() %>% # select the unique well names
  st_as_sf(coords = c("Lon", "Lat")) # set the geographic coordinates

# set coordinate reference system
location <- location %>% 
  st_set_crs(st_crs(us)) # same crs as us df

station_counts <- depth %>% 
  group_by(StnID) %>% 
  summarize(count = n()) %>% 
  filter(count > 10)

# check
##st_crs(location)

# all the points - this isnt super helpful 
ggplot(location) +
  geom_sf(size = 0.5)
  
```


Create a subset of Texas Wells

```{r message=FALSE, warning = FALSE}
# filter for texas
texas <- us %>% 
  filter(name == "Texas")

# plot(texas)

# check
##st_crstexas) == st_crs(location)

# select the well locations within Texas
texas_wells <- location %>% 
  st_intersection(texas)

# select the texas wells that have more than 10 observations
texas_wells_count <- texas_wells %>% 
  filter(StnID %in% station_counts$StnID) # select IDs that match the Texas location

ggplot(texas_wells) +
  geom_sf(size = 0.5)

ggplot(texas_wells_count) +
  geom_sf(size = 0.5)
```

Select all the well data in Texas
- What is the time buffer that I want for the wells? **10 years**

```{r message=FALSE, warning = FALSE}

depth_texas <- depth %>% 
  filter(StnID %in% texas_wells_count$StnID) # select IDs that match the Texas location

  
```



```{r warning = FALSE, message = FALSE}
subset <- depth_texas %>% 
  mutate(year = IntegerYear) %>% 
  filter(StnID == "1000297815") %>% 
  arrange(year)

# generate a time sequence to fill in missing dates
subset_years <- data.frame(year = seq(min(subset$year), max(subset$year)))

# merge years with dataframe
subset <- merge(subset, subset_years, all = T) %>% 
  mutate(valley_flag = ifelse(lag(year, 5) %in% year & lead(year, 5) %in% year, TRUE, FALSE))

ggplot() +
  geom_point(data = subset, 
             aes(x = year, y = DepthToWater_m))
```


```{r eval = FALSE, warning = FALSE, message = FALSE}

valleys_df <- subset %>%
  mutate(valley_flag = ifelse(valley_flag == TRUE, 
                              ifelse(DepthToWater_m <= lag(DepthToWater_m, 5) & DepthToWater_m <= lead(DepthToWater_m, 5), 
                                     "valley", 
                                     "not"), 
                              NA))

ggplot() +
  geom_point(data = valleys_df, 
             aes(x = year, y = DepthToWater_m, color = valley_flag))

```

Create a rolling window and calculate a linear regression each 4 years: 
```{r warning = FALSE, message = FALSE, eval = TRUE}
results <- subset %>%
    mutate(rolling_index = row_number()) %>%
    group_by(rolling_index)

index <- first(results$rolling_index)
start_date <- 1958#results$year[index]
end_year <- start_date + 5
window_data <- results %>%
     filter(year >= start_date & year <= end_year)
lm_results <- lm(DepthToWater_m ~ year, data = window_data)
slope <- summary(lm_results)$coefficients[2] # get the slope
data.frame(start_date = start_date, end_date = end_date, coefficients)


start_date <- 2000
end_year <- 2005
window_data <- results %>%
  filter(year >= start_date & year <= end_year)
lm_results <- lm(DepthToWater_m ~ year, data = window_data)
summary(lm_results)
slope <- summary(lm_results)$coefficients[2] # get the slope
df <- data.frame(start_date = start_date, 
                 end_date = end_year, 
                 slope = slope) 
  
  coef_df <- rbind(coef_df, df)

results <- subset %>%
    mutate(rolling_index = row_number()) %>%
    group_by(rolling_index)

coef_df <- data.frame()

years <- c(results$year)

for(start_year in 1:nrow(results)) {
  
  start_date <- years[start_year]
  end_year <- start_date + 4
  
  window_data <- results %>%
     filter(year >= start_date & year <= end_year)
  
  lm_results <- lm(DepthToWater_m ~ year, 
                   data = window_data)
  slope <- summary(lm_results)$coefficients[2] # get the slope
  df <- data.frame(start_date = start_date, 
                   end_date = end_year, 
                   slope = slope) 
  
  coef_df <- rbind(coef_df, df)
  
}

sub <- data.frame()

seq_yr <- seq(1, nrow(coef_df), by = 4)

for(i in seq(seq_yr)) {
  
  sub <- coef_df[i]  # Select every 5 rows
  print(sub)
  
}

years <- c(results$year)

for(start_year in seq_along(years)) {
  #print(start_year)
  
  start_date <- years[start_year]
  #print(start_date)
  end_year <- start_date + 5
  ##print(end_year)
  window_data <- results %>%
    filter(year >= start_date & year <= end_year)
  
  # Check if there are any NA values in DepthToWater_m
  if (any(is.na(window_data$DepthToWater_m))) {
    next
  }
  
  lm_results <- lm(DepthToWater_m ~ year, 
                   data = window_data)
  slope <- summary(lm_results)$coefficients[2] # get the slope
  df <- data.frame(start_date = start_date, 
                   end_date = end_year, 
                   slope = slope) 
  
  coef_df <- rbind(coef_df, df)
}

```

# Create function for rolling regression

```{r warning = FALSE, message = FALSE}
# Function to calculate rolling linear regression
rolling_lm <- function(data, window_size) {
  
  years <- c(data$year)
  
  coef_df <- data.frame()
  
  for(start_year in seq_along(years)) {
    
    start_date <- years[start_year]

    end_year <- start_date + window_size

    window_data <- results %>%
      filter(year >= start_date & year <= end_year)
    
    # Check if there are any NA values in DepthToWater_m
    if (any(is.na(window_data$DepthToWater_m))) {
      next
    }
    
    lm_results <- lm(DepthToWater_m ~ year, 
                     data = window_data)
    
    slope <- summary(lm_results)$coefficients[2] # get the slope
    
    df <- data.frame(start_date = start_date, 
                     end_date = end_year, 
                     slope = slope) 
    
    coef_df <- rbind(coef_df, df)
  }
  
  return(coef_df)
}

# Calculate rolling linear regression with a 5-year window
rolling_results <- rolling_lm(subset, window_size = 5)

rolling_5 = rolling_results[seq(1, nrow(rolling_results), 5), ]

```


```{r}

ggplot() +
  geom_point(data = subset, 
             aes(x = year, y = DepthToWater_m))

ggplot() +
  geom_line(data = rolling_5, 
             aes(x = start_date, y = slope))

```


