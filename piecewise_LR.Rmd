---
title: "Piecewise Linear Regression for Groundwater Trends"
author: "Luna Herschenfeld-Catalan"
---

# Data Access

## Groundwater Data

Access groundwater data [here](https://zenodo.org/records/10003697). 

Citation: Groundwater level data, aquifer system boundaries, and Supplementary Tables associated with Jasechko, S., Seybold, H., Perrone, D., Fan, Y., Shamsudduha, M., Taylor, R.G., Fallatah, O., Kirchner, J.W. Rapid groundwater decline and some cases of recovery in aquifers globally. Nature, https://doi.org/10.1038/s41586-023-06879-8 (2024).

- Depth to groundwater is saved as `AnnualDepthToGroundwater.csv`. Due to the way its measured, positive slope values signify declines in groundwater. 
- Groundwater elevation is saved as `AnnualGroundwaterElevation.csv`. 

## US data

Accessed us boundary data [here](https://www.census.gov/cgi-bin/geo/shapefiles/index.php?year=2023&layergroup=States+%28and+equivalent%29)

# Data Exploration 

```{r setup, include=FALSE, message=FALSE, warning = FALSE}
library(tidyverse)
library(here)

# to make geospatil objects
library(sf)

library(usmap)

library(forecast)

# fill in the missing NA values
library(performanceEstimation)

library(tidyfit)
library(lubridate)
```


Analysis should include 
```{r message=FALSE, warning = FALSE}
# read in the depth data
depth <- read_csv(here('data', "AnnualDepthToGroundwater.csv"))

# read in the elevation data
elevation <- read_csv(here('data', "AnnualGroundwaterElevation.csv"))

# reda in map data
us <- st_read(here("data", "tl_2023_us_state", "tl_2023_us_state.shp")) %>% 
  janitor::clean_names() %>% 
  select(name, geometry)
```


```{r message=FALSE, warning = FALSE}

location <- depth %>% 
  select(StnID, Lat, Lon) %>% 
  distinct() %>% # select the unique well names
  st_as_sf(coords = c("Lon", "Lat")) # set the geographic coordinates

# set coordinate reference system
location <- location %>% 
  st_set_crs(st_crs(us)) # same crs as us df

station_counts <- depth %>% 
  group_by(StnID) %>% 
  summarize(count = n()) %>% 
  filter(count > 10)

# check
##st_crs(location)

# all the points - this isnt super helpful 
ggplot(location) +
  geom_sf(size = 0.5)
  
```


Create a subset of Texas Wells

```{r message=FALSE, warning = FALSE}
# filter for texas
texas <- us %>% 
  filter(name == "Texas")

# plot(texas)

# check
##st_crstexas) == st_crs(location)

# select the well locations within Texas
texas_wells <- location %>% 
  st_intersection(texas)

# select the texas wells that have more than 10 observations
texas_wells_count <- texas_wells %>% 
  filter(StnID %in% station_counts$StnID) # select IDs that match the Texas location

ggplot(texas_wells) +
  geom_sf(size = 0.5)

ggplot(texas_wells_count) +
  geom_sf(size = 0.5)
```

Select all the well data in Texas
- What is the time buffer that I want for the wells? **10 years**

```{r message=FALSE, warning = FALSE}

depth_texas <- depth %>% 
  filter(StnID %in% texas_wells_count$StnID) # select IDs that match the Texas location

  
```



```{r warning = FALSE, message = FALSE}
subset <- depth_texas %>% 
  mutate(year = IntegerYear) %>% 
  filter(StnID == "1040141399") %>% 
  arrange(year)

# generate a time sequence to fill in missing dates
subset_years <- data.frame(year = seq(min(subset$year), max(subset$year)))

# merge years with dataframe
subset <- merge(subset, subset_years, all = T) %>% 
  mutate(valley_flag = ifelse(lag(year, 5) %in% year & lead(year, 5) %in% year, TRUE, FALSE))

ggplot() +
  geom_line(data = subset, 
             aes(x = year, y = DepthToWater_m))
```


```{r eval = FALSE, warning = FALSE, message = FALSE}

valleys_df <- subset %>%
  mutate(valley_flag = ifelse(valley_flag == TRUE, 
                              ifelse(DepthToWater_m <= lag(DepthToWater_m, 5) & DepthToWater_m <= lead(DepthToWater_m, 5), 
                                     "valley", 
                                     "not"), 
                              NA))

ggplot() +
  geom_point(data = valleys_df, 
             aes(x = year, y = DepthToWater_m, color = valley_flag))

```

Create a rolling window and calculate a linear regression each 4 years: 
```{r warning = FALSE, message = FALSE, eval = TRUE}
results <- subset %>%
    mutate(rolling_index = row_number()) %>%
    group_by(rolling_index)

index <- first(results$rolling_index)
start_date <- 1958#results$year[index]
end_year <- start_date + 5
window_data <- results %>%
     filter(year >= start_date & year <= end_year)
lm_results <- lm(DepthToWater_m ~ year, data = window_data)
slope <- summary(lm_results)$coefficients[2] # get the slope
data.frame(start_date = start_date, end_date = end_date, coefficients)


start_date <- 2000
end_year <- 2005
window_data <- results %>%
  filter(year >= start_date & year <= end_year)
lm_results <- lm(DepthToWater_m ~ year, data = window_data)
summary(lm_results)
slope <- summary(lm_results)$coefficients[2] # get the slope
df <- data.frame(start_date = start_date, 
                 end_date = end_year, 
                 slope = slope) 
  
  coef_df <- rbind(coef_df, df)

results <- subset %>%
    mutate(rolling_index = row_number()) %>%
    group_by(rolling_index)

coef_df <- data.frame()

years <- c(results$year)

for(start_year in 1:nrow(results)) {
  
  start_date <- years[start_year]
  end_year <- start_date + 4
  
  window_data <- results %>%
     filter(year >= start_date & year <= end_year)
  
  lm_results <- lm(DepthToWater_m ~ year, 
                   data = window_data)
  slope <- summary(lm_results)$coefficients[2] # get the slope
  df <- data.frame(start_date = start_date, 
                   end_date = end_year, 
                   slope = slope) 
  
  coef_df <- rbind(coef_df, df)
  
}

sub <- data.frame()

seq_yr <- seq(1, nrow(coef_df), by = 4)

for(i in seq(seq_yr)) {
  
  sub <- coef_df[i]  # Select every 5 rows
  print(sub)
  
}

years <- c(results$year)

for(start_year in seq_along(years)) {
  #print(start_year)
  
  start_date <- years[start_year]
  #print(start_date)
  end_year <- start_date + 5
  ##print(end_year)
  window_data <- results %>%
    filter(year >= start_date & year <= end_year)
  
  # Check if there are any NA values in DepthToWater_m
  if (any(is.na(window_data$DepthToWater_m))) {
    next
  }
  
  lm_results <- lm(DepthToWater_m ~ year, 
                   data = window_data)
  slope <- summary(lm_results)$coefficients[2] # get the slope
  df <- data.frame(start_date = start_date, 
                   end_date = end_year, 
                   slope = slope) 
  
  coef_df <- rbind(coef_df, df)
}

```

```{r}

subset <- subset %>% 
    mutate(index = row_number())
  
  coef_df <- data.frame()
  
for(position in seq(1, nrow(subset), by = 5)) {
    
    start_position <- position

    end_position <- start_position + 5

    window_data <- subset %>%
      filter(index >= start_position & index <= end_position)
    
    # Check if there are any NA values in DepthToWater_m
    if (any(is.na(window_data$DepthToWater_m))) {
      next
    }
    
    lm_results <- lm(DepthToWater_m ~ index, 
                     data = window_data)
    
    slope <- summary(lm_results)$coefficients[2] # get the slope
    
    df <- data.frame(index = position,
                     start_date = start_position, 
                     end_date = end_position, 
                     slope = slope) 
    
    coef_df <- rbind(coef_df, df)
    
    
  }
```


# Create function for rolling regression

```{r warning = FALSE, message = FALSE}
# Function to calculate rolling linear regression
rolling_lm <- function(data, window_size) {
  
  data <- data %>% 
    mutate(index = row_number())
  
  coef_df <- data.frame()
  
  for(position in seq(1, nrow(subset), by = window_size)) {
    
    start_position <- position

    end_position <- start_position + window_size

    window_data <- data %>%
      filter(index >= start_position & index <= end_position)
    
    # Check if there are any NA values in DepthToWater_m
    if (any(is.na(window_data$DepthToWater_m))) {
      next
    }
    
    lm_results <- lm(DepthToWater_m ~ index, 
                     data = window_data)
    
    slope <- summary(lm_results)$coefficients[2] # get the slope
    
    df <- data.frame(index = position,
                     start_date = data$year[start_position], 
                     end_date = data$year[end_position], 
                     slope = slope) 
    
    coef_df <- rbind(coef_df, df)
  }
  
  return(coef_df)
}
```


Want code to be able to detect a case like saudis arabia 
    - Change in sign of slope (if using depth to water: positive to negative slope)
    - Change in magnitude (product of slopes should be negative; difference between change in slopes slopes should be > 0.5m/yr)
    
```{r warning = FALSE, message = FALSE}

source("funs/rolling_lm_index.R")
source("funs/rolling_lm_yr.R")

# Calculate rolling linear regression with a 5-year window
rolling_results <- rolling_lm_index(subset, window_size = 5) %>% 
  
  # calculate the change in slope
  mutate(change = c(NA, diff(slope)),
         
         # calculate the sign change
         sign_change = c(0, diff(sign(slope)))) %>%  
  
  # identify when the magnitude change is greater than 0.5 and the sign changes from pos to neg
  mutate(flag = ifelse(abs(change) >= 0.5 & sign_change == -2,
                       "breakpoint",
                       NA)) %>% 
  filter(flag == "breakpoint")

```


```{r}

ggplot(data = subset, 
             aes(x = year, y = DepthToWater_m)) +
  geom_line() +
  geom_vline(data = rolling_results, 
             aes(xintercept = start_date), 
             color = "red",  # Adjust color as needed
             linetype = "dashed") +  # Adjust linetype as needed
  scale_y_reverse()

```

# Loading in the Houston data
```{r}
houston <- readxl::read_xlsx(here::here("data", "houston_gw.xlsx")) %>% 
  select(Date, DepthToWater_m = DepthToGW_m) %>% 
  mutate(year = stringr::str_extract(Date, ".*(?=\\.)")) %>% 
  mutate(year = as.numeric(year)) %>% 
  group_by(year) %>% 
  summarize(DepthToWater_m = mean(DepthToWater_m)) %>% 
  ungroup()

houston_lm <- rolling_lm(houston, window_size = 4) %>% 
  
  # calculate the change in slope
  mutate(change = c(NA, diff(slope)),
         
         # calculate the sign change
         sign_change = c(0, diff(sign(slope))),
         
         start_date = as.numeric(start_date),
         end_date = as.numeric(end_date)) %>%  
  
  # identify when the magnitude change is greater than 0.5 and the sign changes from pos to neg
  mutate(flag = ifelse(abs(change) >= 0.5 & sign_change == -2,
                       "breakpoint",
                       NA)) %>% 
  filter(flag == "breakpoint")
```


```{r}
ggplot() +
  geom_point(data = houston, 
             aes(x = year, y = DepthToWater_m)) +
  geom_vline(data = houston_lm, 
             aes(xintercept = start_date), 
             color = "red",  # Adjust color as needed
             linetype = "dashed") +  # Adjust linetype as needed
  scale_y_reverse()
```


